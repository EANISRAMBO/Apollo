/*
 * Copyright Â© 2018-2019 Apollo Foundation
 */

package com.apollocurrency.aplwallet.apl.core.consensus.forging;

import com.apollocurrency.aplwallet.apl.core.app.Block;
import com.apollocurrency.aplwallet.apl.core.chainid.BlockchainConfig;
import com.apollocurrency.aplwallet.apl.core.chainid.HeightConfig;
import com.apollocurrency.aplwallet.apl.crypto.Crypto;
import com.apollocurrency.aplwallet.apl.util.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigInteger;
import java.security.MessageDigest;
import javax.inject.Inject;

public class BlockGenerationAlgoProviderImpl implements BlockGenerationAlgoProvider {
    private static final Logger LOG = LoggerFactory.getLogger(BlockGenerationAlgoProviderImpl.class);

    private final BlockchainConfig blockchainConfig;
    @Inject
    public BlockGenerationAlgoProviderImpl(BlockchainConfig blockchainConfig) {
        this.blockchainConfig = blockchainConfig;
    }

    @Override
    public BigInteger calculateHit(byte[] generationSignatureHash) {
        return new BigInteger(1, new byte[] {generationSignatureHash[7], generationSignatureHash[6], generationSignatureHash[5], generationSignatureHash[4], generationSignatureHash[3], generationSignatureHash[2], generationSignatureHash[1], generationSignatureHash[0]});
    }

    @Override
    public long getHitTime(BigInteger effectiveBalance, BigInteger hit, Block block) {
        return block.getTimestamp()
                + hit.divide(BigInteger.valueOf(block.getBaseTarget()).multiply(effectiveBalance)).longValue();
    }

    @Override
    public boolean verifyHit(BigInteger hit, BigInteger effectiveBalance, Block previousBlock, long timestamp) {
        long elapsedTime = timestamp - previousBlock.getTimestamp();
        if (elapsedTime <= 0) {
            return false;
        }
        BigInteger effectiveBaseTarget = BigInteger.valueOf(previousBlock.getBaseTarget()).multiply(effectiveBalance);
        BigInteger prevTarget = effectiveBaseTarget.multiply(BigInteger.valueOf(elapsedTime - 1));
        BigInteger target = prevTarget.add(effectiveBaseTarget);
        return hit.compareTo(target) < 0
                && hit.compareTo(prevTarget) >= 0
                || elapsedTime > 3600;
    }

    @Override
    public int getBlockTimestamp(long hitTime, int generationTimestamp) {
        return (generationTimestamp - hitTime > 3600) ? generationTimestamp : (int) (hitTime + 1);
    }

    @Override
    public byte[] calculateGenerationSignature(byte[] publicKey, Block prevBlock) {
        MessageDigest digest = Crypto.sha256();
        digest.update(prevBlock.getGenerationSignature());
        byte[] generationSignatureHash = digest.digest(publicKey);
        return generationSignatureHash;
    }

    @Override
    public Pair<Integer, Integer> getBlockTimeoutAndVersion(int blockTimestamp, int generationTimestamp, int lastBlockTimestamp,
                                                            int numberOfTxsAtBlockTimestamp, int numberOfTxsAtGenerationTimestamp) {
        HeightConfig currentConfig = blockchainConfig.getCurrentConfig();
        int version = currentConfig.isAdaptiveForgingEnabled() ? Block.REGULAR_BLOCK_VERSION : Block.LEGACY_BLOCK_VERSION;
        int timeout = 0;
        // transactions at generator hit time
        boolean noTransactionsAtTimestamp =
                numberOfTxsAtBlockTimestamp == 0;
        // transactions at current time
        boolean noTransactionsAtGenerationLimit =
                numberOfTxsAtGenerationTimestamp == 0;
        int planedBlockTime = blockTimestamp - lastBlockTimestamp;
        LOG.trace("Planed blockTime {} - uncg {}, unct {}", planedBlockTime,
                noTransactionsAtGenerationLimit, noTransactionsAtTimestamp);
        if (currentConfig.isAdaptiveForgingEnabled() // try to calculate timeout only when adaptive forging enabled
                && noTransactionsAtTimestamp   // means that if no timeout provided, block will be empty
        ) {
            if (planedBlockTime < currentConfig.getAdaptiveBlockTime()) { // calculate timeout only for faster than predefined empty block)
                int actualBlockTime = generationTimestamp - lastBlockTimestamp;
                LOG.trace("Act time:" + actualBlockTime);
                if (actualBlockTime >= currentConfig.getAdaptiveBlockTime()) {
                    // empty block can be generated by timeout
                    version = Block.ADAPTIVE_BLOCK_VERSION;
                } else if (!noTransactionsAtGenerationLimit && actualBlockTime >= planedBlockTime) {
                    // block with transactions can be generated (unc transactions exist at current time, required timeout)
                    version = Block.INSTANT_BLOCK_VERSION;
                } else {
                    return null;
                }
                timeout = generationTimestamp - blockTimestamp;
            } else {
                version = Block.ADAPTIVE_BLOCK_VERSION;
            }
        }
        return new Pair<>(timeout, version);
    }
}
