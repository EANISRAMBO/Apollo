/*
 * Copyright Â© 2018-2019 Apollo Foundation
 */

package com.apollocurrency.aplwallet.apl.core.consensus.forging;

import com.apollocurrency.aplwallet.apl.core.app.Block;
import com.apollocurrency.aplwallet.apl.core.chainid.BlockchainConfig;
import com.apollocurrency.aplwallet.apl.core.chainid.HeightConfig;
import com.apollocurrency.aplwallet.apl.crypto.Crypto;

import java.math.BigInteger;
import java.security.MessageDigest;
import javax.inject.Inject;

public class BlockGenerationAlgoProviderImpl implements BlockGenerationAlgoProvider {

    private BlockchainConfig blockchainConfig;
    private UnconfirmedTransactionDao unconfirmedTransactionDao;

    @Inject
    public BlockGenerationAlgoProviderImpl(UnconfirmedTransactionDao unconfirmedTransactionDao,
                                           BlockchainConfig blockchainConfig) {
        this.unconfirmedTransactionDao = unconfirmedTransactionDao;
        this.blockchainConfig = blockchainConfig;
    }

    @Override
    public BigInteger calculateHit(Long accountId, Block prevBlock) {
        MessageDigest digest = Crypto.sha256();
        digest.update(accountId.toString().getBytes());
        byte[] generationSignatureHash = digest.digest(prevBlock.getId().toString().getBytes());
        return new BigInteger(1, new byte[] {generationSignatureHash[7], generationSignatureHash[6], generationSignatureHash[5], generationSignatureHash[4], generationSignatureHash[3], generationSignatureHash[2], generationSignatureHash[1], generationSignatureHash[0]});
    }

    @Override
    public long getHitTime(BigInteger effectiveBalance, BigInteger hit, Block block) {
        return block.getTimestamp()
                + hit.divide(BigInteger.valueOf(block.getBaseTarget()).multiply(effectiveBalance)).longValue();
    }

    @Override
    public boolean verifyHit(BigInteger hit, BigInteger effectiveBalance, Block previousBlock, long timestamp) {
        Long elapsedTime = timestamp - previousBlock.getTimestamp();
        if (elapsedTime <= 0) {
            return false;
        }
        BigInteger effectiveBaseTarget = BigInteger.valueOf(previousBlock.getBaseTarget()).multiply(effectiveBalance);
        BigInteger prevTarget = effectiveBaseTarget.multiply(BigInteger.valueOf(elapsedTime - 1));
        BigInteger target = prevTarget.add(effectiveBaseTarget);
        return hit.compareTo(target) < 0
                && (hit.compareTo(prevTarget) >= 0)
                || elapsedTime > 3600;
    }

    @Override
    public long getBlockTimestamp(Generator generator, long generationLimit) {
        return (generationLimit - generator.hitTime > 3600) ? generationLimit : generator.hitTime + 1;
    }

    @Override
    public long[] getBlockTimeoutAndVersion(long potentialBlockTimestamp, long currentTimeWithForgingDelay, Block lastBlock) {
        int height = lastBlock.getHeight();
        HeightConfig currentHeightConfig = blockchainConfig.getConfigAtHeight(height, true);
        int version = currentHeightConfig.isAdaptiveForgingEnabled() ? Block.REGULAR_BLOCK_VERSION : Block.LEGACY_BLOCK_VERSION;
        long timeout = 0;
        // transactions at generator hit time
        boolean noTransactionsAtTimestamp =
                unconfirmedTransactionDao.getUnconfirmedTransactions(lastBlock.getNodeId(), potentialBlockTimestamp).size() == 0;
        // transactions at current time
        boolean noTransactionsAtGenerationLimit =
                unconfirmedTransactionDao.getUnconfirmedTransactions(lastBlock.getNodeId(), currentTimeWithForgingDelay).size() == 0;
        long planedBlockTime = potentialBlockTimestamp - lastBlock.getTimestamp();

        log.trace("Planed blockTime {} - uncg {}, unct {}", planedBlockTime,
                noTransactionsAtGenerationLimit, noTransactionsAtTimestamp);
        if (currentHeightConfig.isAdaptiveForgingEnabled() // try to calculate timeout only when adaptive forging enabled
                && noTransactionsAtTimestamp   // means that if no timeout provided, block will be empty
                && planedBlockTime < currentHeightConfig.getAdaptiveBlockTime() // calculate timeout only for faster than predefined empty block
        ) {
            long actualBlockTime = currentTimeWithForgingDelay - lastBlock.getTimestamp();
            log.trace("Act time:" + actualBlockTime);
            if (actualBlockTime >= currentHeightConfig.getAdaptiveBlockTime()) {
                // empty block can be generated by timeout
                version = Block.ADAPTIVE_BLOCK_VERSION;
            } else if (!noTransactionsAtGenerationLimit && actualBlockTime >= planedBlockTime) {
                // block with transactions can be generated (unc transactions exist at current time, required timeout)
                version = Block.INSTANT_BLOCK_VERSION;
            } else {
                return null;
            }
            timeout = currentTimeWithForgingDelay - potentialBlockTimestamp;

            return new long[] {timeout, version};
        }
        if (currentHeightConfig.isAdaptiveForgingEnabled() && noTransactionsAtTimestamp) {
            version = Block.ADAPTIVE_BLOCK_VERSION;
        }
        return new long[] {timeout, version};
    }
}
